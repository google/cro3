# Copyright 2022 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

description     "Start the audit daemon (auditd)"
author          "chromium-os-dev@chromium.org"

# Starts the audit daemon, which catch the message from audit system and
# writes to /var/log/audit

start on starting boot-services
stop on stopping boot-services
respawn

pre-start script
  mkdir -p /var/log/audit
end script

post-start script
  # Wipe all the existing rules.
  auditctl -D

  # Add connect() syscall monitoring.
  auditctl -a always,exit -F arch=b32 -S connect -F success=1 -F key=sock_conn;
  auditctl -a always,exit -F arch=b64 -S connect -F success=1 -F key=sock_conn;
  # Add send() syscall monitoring.
  # TODO(zauri): Gives error on x86_64; can't suppress by -c argument (see man auditctl). One way is to load rules from a file with -i.
  # auditctl -c -a always,exit -F arch=b32 -S send -F success=1 -F key=sock_send;
  # auditctl -c -a always,exit -F arch=b64 -S send -F success=1 -F key=sock_send;
  # Add sendto() syscall monitoring.
  auditctl -a always,exit -F arch=b32 -S sendto -F success=1 -F key=sock_send;
  auditctl -a always,exit -F arch=b64 -S sendto -F success=1 -F key=sock_send;
  # Add sendmsg() syscall monitoring.
  auditctl -a always,exit -F arch=b32 -S sendmsg -F success=1 -F key=sock_send;
  auditctl -a always,exit -F arch=b64 -S sendmsg -F success=1 -F key=sock_send;
  # Add sendmmsg() syscall monitoring.
  auditctl -a always,exit -F arch=b32 -S sendmmsg -F success=1 -F key=sock_send;
  auditctl -a always,exit -F arch=b64 -S sendmmsg -F success=1 -F key=sock_send;
end script

exec /sbin/auditd -n -c /etc/audit
